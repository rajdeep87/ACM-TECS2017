%[FORMAT: 10 page ACM two-column format in 9pt]
\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables

\usepackage{colortbl}

\newcommand{\dkcmt}[1]{{\color{red} [{#1}]}}
\newcommand{\rmcmt}[1]{{\color{magenta} [{#1}]}}
\newcommand{\sjcmt}[1]{{\color{blue} [{#1}]}}
\newcommand{\tmcmt}[1]{{\color{orange} [{#1}]}}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,decorations.markings,chains,fit,shapes.multipart}
\usepackage{import}
\usepackage{times}
\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathptm}
\usepackage{rotating}
\usepackage{color}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{comment}
\usepackage{alltt}
%\usepackage{subfigure}
\usepackage{mdwlist}
\usepackage{multirow}
\usepackage{mathtools}
\usepackage[algo2e,linesnumbered,ruled,lined]{algorithm2e}
\usepackage{url}
\makeatother

\newcommand{\tool}[1]{\textsc{#1}\xspace}
\newcommand{\symex}{\tool{path-symex}}
\newcommand{\ebmc}{\tool{ebmc}}
\newcommand{\hector}{\tool{hector}}
\newcommand{\slec}{\tool{slec}}
\newcommand{\symexv}{\tool{path-symex 5.0}}
\newcommand{\cbmcv}{\tool{cbmc}}
\newcommand{\cbmcver}{\tool{cbmc 5.2}}
\newcommand{\ebmcv}{\tool{ebmc 4.2}}
\newcommand{\hwcbmcv}{\tool{hw-cbmc}}
\newcommand{\hwcbmcver}{\tool{hw-cbmc 5.0}}
\newcommand{\acdcl}{\tool{acdcl}}
\newcommand{\summarizer}{\tool{summarizer 1.0}}
\newcommand{\abc}{\tool{ABC}}
\newcommand{\yosys}{\tool{Yosys 0.5}}
\newcommand{\verifoxver}{\tool{VerifOx 0.1}}
\newcommand{\verifox}{\tool{CoVeriIf}}
\newcommand{\iimc}{\tool{iimc}}
\newcommand{\klee}{\tool{klee}}
\newcommand{\symbiotic}{\tool{symbiotic}}
\newcommand{\kleever}{\tool{klee 1.0.0}}
\newcommand{\symbioticver}{\tool{symbiotic 3.0.1}}

\newcommand{\Omit}[1]{}
\newcommand{\scs}[1]{\scriptsize{#1}}

\input{symbols}
\input{refs}

\title{Mining Scenario/Transaction Pairs in HW/SW Co-verification Using Symbolic Execution}

\Omit{ % Double blind

\author{
\alignauthor
Rajdeep Mukherjee\\
       \affaddr{University of Oxford}\\
       \email{rajdeep.mukherjee@cs.ox.ac.uk}
%
\alignauthor
Saurabh Joshi \\
  \affaddr{IIT, Hyderabad} \\
  \email{sbjoshi@iith.ac.in}
%
\alignauthor
John O'Leary \\
  \affaddr{Intel Corporation, USA} \\
  \email{john.w.oleary@intel.com}
%
\alignauthor
Daniel Kroening \\
  \affaddr{University of Oxford} \\
  \email{kroening@cs.ox.ac.uk}
%
\alignauthor
Tom Melham \\
  \affaddr{University of Oxford} \\
  \email{tom.melham@cs.ox.ac.uk}
}
%
}


%===============================================================================
\begin{abstract}
%===============================================================================
%
Time-to-market pressure requires early development of firmware and other
drivers for circuitry well before RTL is finished.  A key risk is divergence
of the hardware RTL from the behavior expected by the software.  Formal
methods can deliver a proof that the RTL and the firmware match, but are
difficult to scale up.  We propose to identify partitions of the firmware and
the RTL that follow transaction boundaries by means of path-based symbolic
simulation with custom path-pruning.  We have implemented this approach in
our tool \verifox.  We have experimentally compared \verifox with a
conventional approach, which constructs a single monolithic SAT/SMT
instance, and observe speedup of an order of magnitude over conventional 
approach for proving safety properties as well as detecting firmware/hardware bugs.
%
\end{abstract}            

\begin{document}
\settopmatter{printacmref=false} % Removes citation information below abstract
\renewcommand\footnotetextcopyrightpermission[1]{} % removes footnote with conference information in first column
\pagestyle{plain} % removes running headers
\setcopyright{none}

\maketitle

%
%===============================================================================
\section{Introduction}
%===============================================================================
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                    Pre-RTL versus Post-RTL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
Hardware/software co-verification is broadly performed at two different
phases in the design cycle: pre-Register Transfer Level (pre-RTL) and 
post-RTL.  In the pre-RTL phase,
engineers write high-level software (SW) models for Intellectual Property (IP), 
which are commonly known as {\em Transaction Level Model}s
(TLM)~\cite{codes14}.  TLMs are typically implemented using the SystemC TLM
library~\cite{tlm} or as plain C programs.  The goal of a TLM is to capture
enough functionality of the hardware (HW) such that it is possible to execute the
SW (drivers/firmware) against it.  Consequently, the TLMs are
incomplete, as they are designed to contain only those behaviors that are
observable by the SW (the drivers or firmware).  In particular, TLMs
are often not cycle-accurate.  These models are used to verify high-level
functionality of the system well before the RTL is
available~\cite{codes14,codes15}. Co-verification of the TLM and the
SW is typically performed by means of testing~\cite{hvc,codes14}.

In the post-RTL phase, when the RTL design is available, hardware/software
co-verification becomes more complex.  Unlike the TLM, which only captures
limited design functionality, the RTL implements cycle-accurate behavior
of the final HW, and addresses concerns related to power, area and
timing.  The effectiveness of testing 
is thus severely limited in post-RTL co-verification. Verification is mandatory to ensure that the driver or firmware (FW) 
is executed correctly together with the RTL.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                    Challenges in Co-verification 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The verification of a FW given in C/C++ together with an RTL given in a hardware
description language (HDL) such as Verilog/VHDL is a challenging task due to a
few reasons -- 1) the timing and semantic mismatch between the synchronous
clock-driven HW model and asynchronous event-driven SW model. For example, the
FW running on a processor could be much faster than the HW
model it interacts with, 2) lack of support for property specification in 
HW/FW co-designs that can precisely capture the design intent of the 
communication between HW and FW, 3) large
number of interleavings between HW and FW threads, and 4) lack 
of automated formal tools that support co-designs implemented in C/C++ and 
Verilog/VHDL.   In this paper, we address some of these challenges to enable
seamless adoption of formal techniques in hardware/software co-verification.   


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                     Handling Semantic Gap  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Generating a unified FW-HW model for co-verification is a 
well-known phenomenon to handle the semantic mismatch between  
HW~\footnote{Note that whenever we refer to ``hardware'' 
from this point onwards, we mean an RTL implementation 
and not a TLM.}  and FW models.  Most of the existing techniques 
in~\cite{fmsd02,emsoft07,fase10} for constructing a unified FW-HW model are not 
useful in practise for three reasons -- 1) use of abstract HW models 
instead of RTL implementation, 2) the HW-FW model
construction is agnostic to the underlying reasoning engine, and 3) 
it does not leverage the property specification over HW-FW boundary, hence 
ineffective for practical co-verification.  We will call the unified FW-HW 
model as \emph{co-verification model}. 

In this paper, we present two different approaches for automatic formal
verification of HW/SW co-designs -- \emph{monolithic} and \emph{path-based}.  
We embody these techniques in our tools, \hwcbmcv and \verifox, respectively. 


A desirable characteristic of a co-verification model is the ability to exploit 
the expressiveness of the underlying reasoning engines.  To this end, \hwcbmcv
constructs either a bit-level co-verification model that is checked with a SAT solver 
or a word-level model that is checked with an SMT solver.  Whereas, a 
co-verification model in \verifox is constructed 
by first translating the RTL description into a software representation in C,
called \emph{software netlist}, which is then followed by sequentializing the FW 
model and the software netlist model.  This results in a single
threaded sequential co-verification model which is represented in C. A path-wise 
symbolic execution is then performed over the co-verification model to
automatically mine relevant interactions between the FW and HW models.   


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                     Co-specification Model  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Lack of support for property specification in a HW/SW co-design is one of the
stumbling blocks for the application of formal techniques in co-verification.  
In this paper, we express a co-design property in C 
with the support of special primitive, called {\em next\_timeframe()}, 
that can express temporal correlation between HW and FW events. 
The co-design properties captures the overall design intent that enables
specification of system-level properties across HW/SW boundaries. Thus, 
they are sufficiently expressive, amenable to verification reuse and can be 
readily used in assertion-based verification.  Closest to our
unified property specification for co-verification is the language
\textit{xPSL}~\cite{xPSL} proposed by Xie et al., which is the extension of IEEE PSL.  
Note that the co-verification models in \hwcbmcv and \verifox are fully compliant 
with our specification language, hence easily amenable to verification.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %       Scenario, Transaction and Scenario/Transaction Pair
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A firmware only exercises a fraction of the hardware state-space in a typical 
hardware/software
co-design~\cite{polig2014micro,polig2014fpl,giefers2015accelerating}.  
A firmware services the requests from the application software 
layer or its interacting hardware.  Similarly, the hardware services 
the requests from the firmware or the
physical environment.  Thus, the firmware and its interacting hardware
components can be seen as a set of services.  In this paper, we call a
hardware RTL service a {\em Hardware Transaction} $(\mathcal{HT})$.  Closest
to our notion of $\mathcal{HT}$ is the micro-architecture-level transaction
by Mahajan et al.~\cite{mcbmq}.  We call a FW service a {\em Firmware
Transaction} ($\mathcal{FT}$).  $\mathcal{FT}$ is an untimed finite-state
machine that is manifested as control-flow paths in the FW, similar to
transactions in TLM~\cite{codes14}.  A~{\em scenario} $(\mathcal{S})$ in a
co-design typically configures the co-verification environment in a way that
restricts the interaction between $\mathcal{FT}$ and $\mathcal{HT}$.  In
other words, given a scenario $\mathcal{S}$, the FW exercises only a fragment
of the HW state-space.  This renders many interactions between
$\mathcal{HT}$ and $\mathcal{FT}$ infeasible. For example, a scenario in 
\emph{Universal Asynchronous Receiver Transmitter} (UART) IP can configure the 
UART in \emph{transmitter} mode which restricts the communication between the FW 
and HW to set of services that only transfer data from the FW to the serial output 
port of the transmitter HW while completely bypassing the receiver HW.  
A {\em Scenario/Transaction} pair is a set of valid interactions between 
$\mathcal{HT}$ and $\mathcal{FT}$ for a particular scenario~$\mathcal{S}$.  
It is necessary to automatically mine Scenario/Transaction pairs for scalable 
and effective co-verification.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %        Difference between Monolithic and Path-wise Approach
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A monolithic approach in \hwcbmcv is based on Bounded Model Checking~\cite{CKY03}, 
hence it cannot exploit the infeasibility arising from scenario driven
partitioning of HW-FW interaction behaviors.  Whereas, a path-based symbolic 
execution in \verifox can automatically infer such Scenario/Transaction 
pairs and check their validity using backend solvers.  We experimentally 
show that for building an effective and scalable formal co-verification tool, 
it is imperative to automatically mine only relevant scenario/transaction 
pairs that occur in practical co-design environment. 
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %                        Concurrency   
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A co-design system is comprised of a set of concurrent FW and HW transactions 
which interleaves asynchronously. It is well recognized that concurrency is at
the heart of co-verification. The number of interleavings between the FW
and HW threads can be large, which can become a bottleneck in the
verification process.  
However, we observe that in practice, industrial co-designs exhibit 
producer-consumer
relationships~\cite{polig2014micro,polig2014fpl,giefers2015accelerating} --
the master module (producer) solely updates the shared registers which are
consumed by the slave (consumer).  This key observation allows us to
sequentialize concurrent FW and HW models \sjcmt{transactions instead of models?} that follow specific interaction
patterns.  This drastically reduces the total number of interleavings 
between a FW and HW threads and simplies the overall complexity of the 
verification task. 
%
%===============================================================================
%\subsection{Contributions}
%===============================================================================
In this paper, we make the following contributions:
\begin{enumerate}
  
  \item \textbf{Monolithic versus Path-based:} We present two approaches for formal hardware/software co-verification
    -- 1) A \emph{monolithic} approach that clearly separates the symbolic
    execution of HW and FW model and generate a monolithic SAT query for 
    verification purpose, 2) A \emph{path-based} approach that constructs
    an unified sequential co-verification model from HW and FW models and
    generates multiple SAT queries that encodes relevant scenario/transaction 
    pairs using symbolic execution.  
    
    To the best of our knowledge, this is the first attempt to synthesize a pure 
    software co-verification model from C/RTL co-designs specifically targeted 
    for formal analysis.   
  
  \item \textbf{Co-verification Tools:} We present an automatic HW/SW co-verification tool called, \hwcbmcv,
    which follows the monolithic verification technique.  Our path-based 
    approach is implemented in a tool called, \verifox. Both tools can handle
    co-designs where the hardware is implemented in Verilog RTL (IEEE
    SystemVerilog 2005 standards) and the firmware is  
    specified in ANSI-C (C89, C99 standards).  We distribute the HW/SW 
    co-verification tools, \hwcbmcv and \verifox, along with our co-design 
    benchmarks in Verilog RTL and C models 
    here~\footnote{https://drive.google.com/folderview?id=0BynC6sd-wTYgWVQ4bXNtRDB5a2c\&usp=sharing}.\rmcmt{check
    link}

  \item \textbf{Property Specification Language:} We present a unified property
    specification language for co-verification that allows engineers to write meaningful 
     formal co-specification over hardware and firmware events and specify
     temporal correlations between these events.  Our tool also supports a
     fragment of IEEE Property Specification Language. 
     
     %We believe that the formal
     %co-specification model will significantly ease the adoption of formal tools 
     %for co-verification of industrial strength co-designs. 
    
\end{enumerate}
%
%===============================================================================
\section{Working Example}
%{\bf Running example: }
%===============================================================================
In this section, we present a working example of FW and HW model to explain our 
co-verification methodologies.  

\textbf{Firmware Model} Figure~\ref{firmware} gives a fragment of a FW model for a Universal 
Asynchronous Transmitter/ Receiver (UART) IP.  The
$wb$ class of functions communicate with the {\em wishbone} bus interface to
set/reset the UART input ports and read/write data through the bus
interface.  The FW implements Linux style inb() and outb() functions which
invokes the $wb$ functions to communicate with the UART.  The FW begins 
by resetting the UART IP which is followed by a $wb\_idle()$ function.  The 
FW then configures the UART in {\em loopback} mode using $outb$ function calls. 
Inside the loop, the firmware checks for a {\em transmitter} or {\em
receiver} interrupt by reading the Interrupt Status register $(UART\_IS)$. 
Depending on the type of interrupt, the firmware either receives a data packet 
or sends a data packet over the serial output.  The $set\_inputs()$ and
$next\_timeframe()$ functions, used in $wb$ functions, are 
firmware primitives that direct our tool to set the inputs to the HW signals 
and advance the HW clock, respectively.

\textbf{Interface functions} The \emph{interface functions} are lowest level of 
implementation in a FW model that directly read from or write to the HW ports. 
For example, the interface functions in figure~\ref{firmware} are the $wb$ class
of functions that directly wiggles the input/output ports of UART HW.


\textbf{Hardware Model} Figure~\ref{fig:interleaving2} shows a fragment of the state machine 
implementation of the UART hardware RTL.  The UART IP contains a
\emph{transmitter} module, a \emph{receiver} module and a \emph{clock
generator}.  The update of state elements (\emph{registers}) and 
\emph{wires} are shown in rectangular boxes and rounded boxes respectively.  

\textbf{Co-design Property} We verify that the transmitted data is the same as the 
received data in the {\em loopback} mode.  To do so, we annotate the FW model 
with an assertion $assert()$, as shown in Figure~\ref{firmware}.  Note that the 
array containers $rx\_b$ and $tx\_b$ stores the data obtained through the $inb$
and $outb$ function calls which directly read from and write to the UART IP ports
respectively. Section~\ref{property} describes the property specification in
HW-FW co-designs in more detail. 
\[
  for(i=0; i<=N; i++) 
   \quad assert(rx\_b[i] == tx\_b[i]);
\]
%
\section{Scenario and Transaction}
%
We describe the notion of \emph{transaction} and \emph{scenario} with the
help of our working example. \\
%
\begin{figure}[t]
\scriptsize
\begin{tabular}{|l|l|}
\hline
Wishbone Interface & Main Module \\
\hline
\begin{lstlisting}[mathescape=true,language=C]
typedef unsigned char u8;
unsigned char inb 
 (unsigned long port) {
  return wb_read(port);
}
void outb (u8 value, 
 unsigned long port) {
  wb_write(port, value);
}
void wb_reset(void) {
 rst_i = 1;
 set_inputs();
 next_timeframe();
 rst_i = 0;
 stb_i = 0; 
 cyc_i = 0;
}
void wb_idle() {
 set_inputs();
 next_timeframe();
}
void wb_write(_u32 addr, 
     _u8 b) {
 adr_i = addr;
 dat_i = b;
 we_i = 1;
 cyc_i = 1;
 stb_i = 1;
 set_inputs();
 next_timeframe();
 we_i = 0;
 cyc_i = 0;
 stb_i = 0;
}
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true,language=C]
int main() {
wb_reset();
wb_idle();
// Configure the uart
outb (0x13, UART_MC);  
outb (0x80, UART_CM3);
outb (0x00, UART_CM2);
outb (0x00, UART_CM1);
outb (0x00, UART_CR);  
outb (0x03, UART_IE); 
char tx_b[] = "Hello world";
_u8 status = 0;
char rx_b[100];
int i=0,c=0,d=0;
// data transfer in loopback
for (i=0; i<1990; i++){
if (irq_o){
 status=inb(UART_IS)&0x0c;
 if(istatus==0x0c){
 //it was a tx_empty interrupt
 outb(*(tx_b+c),UART_TR); c++;
 }
 else{ //status==0x04
 //it was an rx_data interrupt
  rx_b[d] = inb(UART_TR); d++;
 }
}else {
 // no interrupt. 
 wb_idle();
 wb_idle();
 }
}
// property
for(i=0; i<=10; i++)
 assert(rx_b[i] == tx_b[i]);
}
\end{lstlisting}
\\
\hline
\end{tabular}
\caption{Firmware model of UART IP}
\label{firmware} 
\end{figure}
%


\textbf{Scenario ($\mathcal{S}$):}
Let $B$ denote the set of all possible behaviors of a system. A scenario is a set of 
constraints $\mathcal{S}$ that restrict the system behaviors
to $B' \subseteq B$. For example, the left hand side of Figure~\ref{fig:st} 
gives an example scenario for the UART FW shown in Figure~\ref{firmware}. 
Here, $\mathcal{S}$ configures the UART IP in {\em loopback} mode with 
interrupt enabled.

\Omit{ 
\textbf{Use case:}
A {\em Use case} is a set of scenarios that satisfy 
a particular goal. A use case completes successfully 
when that goal is satisfied. A complete set of use cases 
defines all the behaviors required of the system. For example, 
a use case in case of UART IP may be to transmit 
the data through the serial port. A scenario is an 
instance of a use case. 
}
%
\begin{figure}[t]
\scalebox{.55}{\import{figures/}{st.pspdftex}}
\caption{Scenario and Firmware Transaction
\label{fig:st}}
\end{figure}

\textbf{Firmware Transaction ($\mathcal{FT}$):} 
A Firmware Transaction ($\mathcal{FT}$) is an untimed state machine 
with a start state and an end state, which is similar to the notion of 
a transaction in TLM~\cite{codes14}. 
Each transition in $\mathcal{FT}$ is guarded with a quantifier free predicate
over FW variables and HW signals.
If the guard evaluates to $TRUE$, it may perform some action, which may  
read/write data. If the guard is not specified, it is assumed to be $TRUE$.
$\mathcal{FT}$ is often manifested as control-flow paths in the firmware. 
The right hand side of Figure~\ref{fig:st} gives a 
$\mathcal{FT}$ for the UART firmware code shown in Figure~\ref{firmware}. 
It has a start state and an end state. $\mathcal{FT}$ is triggered from 
UART output signal, $irq_o$. An execution of $\mathcal{FT}$, also called a 
FW transaction instance, takes a simple path from the start state to the end state. 
The path taken by an execution is determined by the state of 
the FW variables or its interacting HW signals. Repeated execution of 
$\mathcal{FT}$ can happen only in a sequential manner \sjcmt{not clear what this means}.  
 
\textbf{Hardware Transaction ($\mathcal{HT}$):} 
Let us consider a HW RTL design with \textit{input} $\{I\}$, 
\textit{output} $\{O\}$, \textit{wires} $\{Wire\}$ and a set of 
state elements such as \textit{Registers} $\{Reg\}$, \textit{Memory}
$\{Mem\}$ ($Mem$ is a sequence of registers). Here, 
$\{I\} \subseteq \{Wire\}$, and $\{O\} \subseteq \{Reg\} \cup \{Wire\}$.
All state elements are fixed-width unsigned integers. 

Let $\mathcal{G}$ be the set of quantifier free boolean predicates over 
state elements, $\{Reg\}$, $\{Mem\}$, $\{Wire\}$.  
A {\em transaction step}, $\varphi$, is defined by a 2-tuple,
$\varphi \equiv \langle \Gamma_{\varphi}, \Delta_{\varphi} \rangle$, where 
$\Gamma_{\varphi} \equiv \{\alpha_1, \alpha_2, \ldots \alpha_{m}\}$
is a set of concurrent state updates to $\{Reg\}$, $\{Mem\}$, $\{Wire\}$ 
and $\Delta_{\varphi} \equiv \{\beta_1, \beta_2, \ldots \beta_{n}\} \subseteq
\mathcal{G}$.

A {\em Hardware Transaction} $(\mathcal{HT}) = (V, \Sigma, \rightarrow, init,
comp)$ is a labelled transition system, where $V$ is a set of transaction steps
$\varphi$ with a unique source vertex, $init \in V$, and a unique sink vertex, 
$comp \in V$, $\Sigma$ is a set of labels such that $\Sigma \subseteq 2^{G}$ \sjcmt{2 power G may not be required, just G may be sufficient as it is closed under disjunction, conjunction and negation} and  
$\rightarrow \subseteq V \times \Sigma \times V$ is a set of labelled
transitions.

Each execution of $\mathcal{HT}$ is a non-empty 
sequence of transaction steps where each transaction step 
happens in a single clock. The first step is called {\em initiation event}
(\textit{init}). Assuming the duration of $\mathcal{HT}$ is finite, 
there must exist some distinguishable last completion event (\textit{comp}). 
%Operationally, an execution of $\mathcal{HT}$ begins at \textit{init}. 
After a transaction step $\varphi$ is executed, the set of concurrent state
update $\Gamma_{\varphi}$ is carried out and the value of boolean predicates
in $\Delta_{\varphi}$ is evaluated to determine the next step
$\varphi_{next}$, that is, a predicate $\beta_i \in \Delta_{\varphi}$
enables a transaction step.  This process continues until $\mathcal{HT}$
reaches \textit{comp} state.  Note that $\mathcal{FT}$ can update some state
elements of $\mathcal{HT}$ during its write action, based on which
predicates in $\Delta_{\varphi}$ may be computed. 

Figure~\ref{fig:interleaving2} shows a fragment of $\mathcal{HT}$
corresponding to the top module of UART IP.  Let us consider a possible
execution of $\mathcal{HT}$, $(init \rightarrow t_1 \rightarrow t_4
\rightarrow t_6 \rightarrow comp)$.  At $init$, the FW sets the HW input
signal, $(rst\_i==0)$, based on which the execution follows the edge to
$t_1$.  At $t_1$, the predicate, $cs$, is computed based on HW input
signals, $cyc\_i$, $stb\_i$, $adr\_i$ and $we\_i$.  Assuming that $cs\_i
\&\& we\_i$ holds true, the execution proceeds to step $t_4$ which computes
predicates based on the values in $adr\_i$.  The next step is determined by
the values of predicates, $'UART\_MC, 'UART\_IE, 'UART\_CT$.  Assuming that
$'UART\_MC$ holds true, the execution proceeds to $t_6$.  During the
execution of $t_6$, three parallel state update $(dtr\_no, rts\_no,
loopback)$ and two predicate evaluation ($\beta_1,\beta_2)$ is performed
based on the updates to state elements.  After $t_6$, the execution of
$\mathcal{HT}$ leads to $comp$ and the transaction finishes its execution. 
Note that the dotted edges in $\mathcal{HT}$ denotes that eventually the
execution reaches $comp$.  The update of state elements are shown in
rectangular boxes, whereas the evaluation of boolean predicates are shown
inside the rounded boxes.  The blue arrows point to the state updates or
predicate evaluation at a particular~$\varphi$. \\
%
\begin{figure}[t]
\scalebox{.50}{\import{figures/}{fw-hw-interleaving.pspdftex}}
\caption{Some HW Transactions for UART
\label{fig:interleaving2}}
\end{figure}
%
\textbf{Scenario/Transaction Pairs}
%
A scenario, $\mathcal{S}$, restricts the interaction between $\mathcal{HT}$
and $\mathcal{FT}$.  Similar to service-function based transaction in
TLM~\cite{hvc}, we view $\mathcal{FT}$ and $\mathcal{HT}$ as a set of
service in response to its interacting $\mathcal{HT}$ or $\mathcal{FT}$,
respectively.  A {\em Scenario/Transaction} pair is a set of valid
interactions between $\mathcal{HT}$ and $\mathcal{FT}$ for a
particular~$\mathcal{S}$.  For example, an UART IP contains a {\em
transmitter} and a {\em receiver} module.  Let us assume that a scenario,
$\mathcal{S}$, configure a UART in {\em transmission} mode.  Then the
interaction between $\mathcal{FT}$ and $\mathcal{HT}$ is constrained to
contain only those interactions that are relevant to the {\em transmitter}
module.  By contrast, the interactions with respect to the {\em receiver}
module is irrelevant for $\mathcal{S}$.  However, when $\mathcal{S}$
configures a UART in {\em loopback} mode, then the interaction between
$\mathcal{FT}$ and $\mathcal{HT}$ must contain transactions in {\em
transmitter} as well as {\em receiver} module.
%
\section{Proposed Methodology}
%
\subsection{Approach 1: Path-based Co-verification Technique}
%
Figure~\ref{proposed-flow} describes our overall tool framework. In the
subsequent section, we describe each step in detail.\\ 
%
\begin{figure}[t]
%\centering
\scalebox{.48}{\import{figures/}{work-flow.pspdftex}}
\caption{\small Path-based HW/SW Co-verification Flow in \verifox
\label{proposed-flow}}
\end{figure}
%
\textbf{Step 1: RTL to Software}
A hardware circuit in Verilog RTL is automatically 
translated into a word level C program, called a 
\textit{software netlist}~\cite{mtk2016,mskm2016,mkm2015} following synthesis 
semantics \sjcmt{ref for synthesis semantics?}. The software netlist model is cycle-accurate as well as 
bit-precise~\footnote{http://www.cprover.org/hardware/v2c/}. The 
translation automatically handles concurrent statements 
in Verilog such as procedural blocks and continuous assignments, multiple {\em always}
blocks, multiple modules, and translates them into an equivalent \sjcmt{we should specify equivalent in what sense} C program.  This
is a radically new but promising approach for synthesizing software 
models from RTL description, primarily targeted for word-level formal hardware 
verification using software verification techniques such as abstract 
satisfaction\sjcmt{?}~\cite{leo-thesis}.  To the best of our knowledge, this is the first 
attempt to demonstrate the efficacy of such a translation in the context of 
hardware/software co-verification. 
% 
A \textit{software netlist} $\mathcal{SN}$ is defined as follows:
%
\[ 
\begin{array}[t]{@{}lll}
\mathcal{SN} & {:}{:}{=} & \mathit{Modules} \\
\mathit{Modules} & {:}{:}{=} & \epsilon \mid \mathit{moduleName(Var_1,\dots,Var_n)} \{ Asgn \} \;\; Modules \\
\mathit{Asgn} &  {:}{:}{=} & \mathit{CAsgn} \mid \mathit{SAsgn} | moduleName(Var_1,\dots,Var_n)\\
\mathit{CAsgn} & {:}{:}{=} & (V_c := Bv) \mid (V_c := \mathit{Bool}), \quad V_c \in \mathit{Comb} \uplus \mathit{Out} \\
\mathit{SAsgn} & {:}{:}{=} & (V_s := Bv) \mid (V_s := \mathit{Bool}), \quad V_s \in \mathit{Seq} \\
\mathit{Bv} &  {:}{:}{=} & bv_{const} \mid bv_{var} \mid
	\mathit{ITE}(Bool, Bv, Bv) \mid
bv_{op}(bv_1, \ldots, bv_n), \\
& & bv_i \in Bv, \\ 
& & bv_{op} \in \{n-\text{ary operators over bitvectors} \} \\
\mathit{Bool} & {:}{:}{=} & \mathit{true} \mid \mathit{false} \mid \neg{Bool} \mid Bool \land Bool \mid 
Bool \lor Bool \mid \\ 
& & Bv\; relop\; Bv, relop \in \{<,\leq,=,>,\geq\} \\
\end{array}
\]
%
Here, $\mathit{In}$ \sjcmt{this is missing from the def}, $\mathit{Out}$, $\mathit{Seq}$, $\mathit{Comb}$
are program variables that model \emph{input}, \emph{output}, 
\emph{sequential/state-holding} and \emph{combinational/stateless} 
signals in the circuit.  $Asgn$ is a finite set of assignments 
to $Out$, $Seq$ and $Comb$. Figure~\ref{ex1} shows an example of 
Verilog RTL circuit containing an {\em always} block and continuous
assignment statements, and the equivalent software netlist in C.
%
\begin{figure*}[t]
\scriptsize  
\centering
\begin{tabular}{|l|l|l|l|}
\hline
  Verilog & Formal Semantics & Synthesized Hardware & Software netlist \\
\hline
\begin{lstlisting}[mathescape=true,language=Verilog]
module top(clk, a);
input clk, a;
reg b,d,e; 
wire c,cond;
assign c = e ? 1'b0:d;
assign cond = a;
always @(posedge clk) 
 begin
  b<=a;
  if(cond && b)
   e<=b;
  else 
   e<=0;
  d<=c;
 end
endmodule
\end{lstlisting}
&
\begin{minipage}{4.2cm}
%\centering
\scalebox{.5}{\import{figures/}{semantics.pspdftex}}
\end{minipage}
&
\begin{minipage}{4.0cm}
\centering
\scalebox{.5}{\import{figures/}{ckt.pspdftex}}
\end{minipage}
&
\begin{lstlisting}[mathescape=true,language=C]
struct state_elements_top {
 unsigned int b, d, e; };
struct state_elements_top  u1;
void top(_Bool clk, unsigned a) {
  _Bool c,cond;
  _Bool b_old=u1.b, d_old=u1.d;
  _Bool e_old=u1.e;
  cond = a;
  c = (u1.e)?0:u1.d;
  u1.b = a;
  if(cond && b_old)
    u1.e = b_old;
  else
    u1.e = 0;
  u1.d = c;  
}
\end{lstlisting}
\\
\hline
\end{tabular}
\caption{Circuit to Software}
\label{ex1}
\end{figure*}
%

\textbf{Step 2: Sequentialization based on Transaction Interaction}
%
Concurrency is at the heart of co-verification.  Testing concurrent 
threads requires exploring all possible interleavings between HW 
and FW threads.  The number of interleavings could potentially be  
exponential.  However,~\cite{codes14,hvc} showed that the 
interaction between a FW thread and a HW thread follows a 
producer-consumer relationship. That is, a FW 
thread is mostly independent of the HW thread they interact with~\cite{hvc,codes14}.  
Specifically, a FW thread is only responsible for configuring the 
HW transactions by writing to memory mapped registers, or polling 
the interrupt status register for data transmission, or receiving 
incoming data packets. 


Furthermore, we observe producer-consumer interaction pattern 
in many practical industrial co-designs, such as IBM 
Text Accelerator co-design~\cite{polig2014micro,polig2014fpl}, 
IBM coherent FFT coprocessor~\cite{giefers2015accelerating}, RockBox 
Media Player~\cite{hvc}, linux device driver interacting with QEMU emulated
hardware code~\cite{codes14}.  


%This interaction pattern exhibits producer-consumer 
%relationship, which is also evident in case of our UART example in 
%Figure~\ref{fig:interleaving1}.  
%
A communicating pair of executions of 
$\mathcal{FT}$ and $\mathcal{HT}$ is an {\em interaction}, which 
takes place through shared variables (or shared registers)
only.  An interaction is said to exhibit {\em producer-consumer}
interaction pattern if 1) the set of variables $V$ written by 
the execution of $\mathcal{FT}$ and and the set of variables 
$V'$ written by the execution of $\mathcal{HT}$ are disjoint 
($V \cap V' = \emptyset$), (2) and the executions 
of $\mathcal{FT}$ and $\mathcal{HT}$ consumes values 
in $V'$ and $V$, respectively.
%


Figure~\ref{fig:interleaving1} illustrates the producer-consumer relationship 
in UART IP. The FW CFG is shown in the left and the 
HW RTL code snippet is shown in the right. We abuse notations and 
represent $\mathcal{HT}$ in the form of RTL and $\mathcal{FT}$ as CFG
for our illustration purpose. Here, $\mathcal{HT}$ is the producer of interrupt 
status signal, $irq\_o$, which is read by $\mathcal{FT}$ in state $s_1$. 
The signal $irq\_o$ is  triggered when transmitter buffer is 
{\em EMPTY} or receiver buffer is {\em FULL}. 
$\mathcal{HT}$ also produces interrupt status by writing to the 
memory mapped register, $UART\_IS$, which is consumed by 
$\mathcal{FT}$ in state $s_2$.  In another interaction, $\mathcal{HT}$
sends a data-packet to $UART\_TR$ which is consumed by $\mathcal{FT}$ in state $s_7$.
Similarly, $\mathcal{FT}$ is the producer of $data$, $(outb(data,UART\_TR))$, 
in state $s_6$ which is consumed by $\mathcal{HT}$.  
%
\begin{figure}[t]
\scalebox{.55}{\import{figures/}{interleaving.pspdftex}}
\caption{Producer Consumer Interactions Pattern
\label{fig:interleaving1}}
\end{figure}
%
Table~\ref{transaction} shows the FW transactions $(\mathcal{FT})$ and its 
interacting HW transactions $(\mathcal{HT})$ from Figure~\ref{fig:interleaving1}. 
The description above the arrows 
in column 1 shows the events in $\mathcal{FT}$ and the letter below the
arrows denotes the event type, producer $(\mathcal{P})$ or consumer 
$(\mathcal{C})$. Arrows with empty description below denotes reading of interface
variables or local variables in $\mathcal{FT}$.  Arrows with no description
simply denotes control-flow join.  The entries in the right column of
Table~\ref{transaction} shows the corresponding transactions in HW.  We 
denote a transaction in HW module with the name of the module,
transmitter module in UART ($uart\_tx$), receiver module in UART ($uart\_rx$), or
the top UART module ($uart\_top$).
%
\begin{table}
\begin{center}
{
 \scriptsize
\begin{tabular}{|c|c|c|}
\hline
  Firmware & Hardware  \\
  Transaction ($\mathcal{ST}$) & Transaction ($\mathcal{HT}$) \\ 
\cline{1-2}
   $s_1 \xrightarrow[]{irq_o} s_2 \xrightarrow[\mathcal{C}]{inb()} s_4
   \xrightarrow[]{status == 0x0c} s_6 \xrightarrow[\mathcal{P}]{outb()} s_9 \rightarrow
   s_{11} \rightarrow s_{12}$  & $s_2 \xrightarrow[\mathcal{C}]{inb()} s_4\;\; uart\_{rx}$
   \\ 
   & $s_6 \xrightarrow[]{outb()} s_9\;\; uart\_{tx}$ \\  \hline
   
   $s_1 \xrightarrow[]{irq_o} s_2 \xrightarrow[\mathcal{C}]{inb()} s_4
   \xrightarrow[]{status \neq 0x0c} s_7 \xrightarrow[\mathcal{C}]{inb()} s_{10} \rightarrow
   s_{11} \rightarrow s_{12}$  & $s_2 \xrightarrow[\mathcal{C}]{inb()} s_4\;\; uart\_{rx}$
   \\ 
   & $s_7 \xrightarrow[]{outb()} s_{10}\;\; uart\_{rx}$ \\  \hline
   
   $s_1 \xrightarrow[]{\neg irq_o} s_3 \xrightarrow[]{wb\_{idle()}}
   s_5 \xrightarrow[]{wb\_{idle()}} s_8 \rightarrow
   s_{12}$ & $s_3 \xrightarrow[]{wb\_{idle()}} s_5\;\; uart\_{top}$ \\ 
   & $s_5 \xrightarrow[]{wb\_{idle()}} s_8\;\; uart\_{top}$ \\  \hline
\end{tabular}
}
\end{center}
\caption{\small Firmware Transactions and interacting HW transactions}
\label{transaction}
\end{table}  
%


\textbf{Step 3: Co-verification Model}
%
An unified co-verification model is constructed through appropriate composition of 
FW and its interacting HW threads.  This is done by instrumenting the 
software netlist model of HW RTL inside the FW thread at every invocation 
of the $next\_timeframe()$ primitive in interface functions.  Recall that a
call to $next\_timeframe()$ is used to advance the HW clock by one cycle.  A call
to the software netlist emulates the effect of one clock period in the RTL 
model. That is, the state of state holding elements (registers) and combinational 
elements (wires) are uniform in software netlist and RTL model after every invocation of 
$next_timeframe()$.  Furthermore, a software
netlist is a sequential model of HW RTL which is represented in C.  Thus, the
composition leads to a single-threaded sequential co-verification model in C.  
%
We now formally define a our co-verification model, denoted by 
$\mathcal{M}_{seq}$.
%
\[ 
\begin{array}[t]{@{}lll}
  \mathcal{M}_{seq} & {:}{:}{=} & \mathit{Procedure} \\
\mathit{Procedure} & {:}{:}{=} & \mathit{Statement} \mid \mathit{Procedure} \\
\mathit{Statement} & {:}{:}{=} & CStatement \mid \mathit{moduleName(Var_1,\dots,Var_n)} \\
\mathit{CStatement} & {:}{:}{=} & x {:}{=} exp \mid \mathit{ITE}(b, s_1,s_2) \mid \mathit{s_1;s_2} \mid loop\{s\} \\ 
\end{array}
\]
%
Consider sets of expressions $Exp$ and Boolean expressions $BExp$ 
over variables $Var$ of $\mathcal{M}_{seq}$ such that $(exp \in Exp)$ and 
$(b \in BExp)$. A $\mathit{CStatement}$ is an assignment,
conditional, sequential concatenation or a loop.
$\mathit{moduleName(Var_1,\dots,Var_n)}$ invokes the top level 
procedure of $\mathcal{SN}$, which is also the top level 
module of the HW RTL, since the translation from RTL to software preserves
the module hierarchy.  The interface variables $\{Var\_1,\dots,Var\_n\}$ 
(input, output and inout ports) are declared inside the 
FW to communicate with $\mathcal{SN}$.  Figure~\ref{compose} shows the 
composition of $\mathcal{SN}$ and FW thread for the UART IP.
%
\begin{figure}[t]
\scalebox{.50}{\import{figures/}{compose.pspdftex}}
  \caption{Composition of FW and HW threads}
\label{compose}
\end{figure}


\textbf{Step 4: Property Driven Slicing of Co-verification Model}
A property-driven slicing is performed on the unified model, $\mathcal{M}_{seq}$.  
This step is purely syntactic, meaning that we perform a backward dependency 
analysis starting from the property which only preserve those 
program fragments that are relevant to a given property. The sliced program 
is then passed to the symbolic execution engine for path-based exploration. \\
%
%=======================================================================================
%\subsection{\verifox: Path-wise Symbolic Execution Tool} 
%=======================================================================================
\input{verifox}
%
\subsection{Approach 2: Monolithic Co-verification Technique}
%
\begin{figure}[t]
\begin{center}
\includegraphics[scale=0.6]{figures/traditional_flow.pdf}
\caption{\small Monolithic HW/SW Co-verification Flow in \hwcbmcv}
\label{fig:conventional}
\end{center}
\end{figure}
%
\textbf{Step 1: Co-verification Model}
%
Figure~\ref{fig:conventional} illustrates the monolithic approach to HW/SW
co-veri\-fi\-cation, as implemented in \hwcbmcv.  
%\hwcbmcv is the only open-source
%formal co-verification tool that supports Verilog RTL (System Verilog 2009
%standard) and C/C++ firmware.  
In contrast to path-based approach,
\hwcbmcv maintains two separate flows for HW and FW.  The top flow in
Figure~\ref{fig:conventional} uses synthesis to obtain either a bit-level or
a word-level netlist from Verilog RTL.  A bit-level netlist is represented 
in And Inverter Graph (AIG) format.  Whereas, a word-level netlist is represented 
in format that resembles SMT-LIB standards.  The bottom flow illustrates the
translation of C program into static single assignment (SSA) form. 
Synthesizing netlist from RTL is a standard technique which is widely 
used in hardware model checkers~\cite{DBLP:journals/tse/Clarke76}.
Similarly, translating a C program into a SSA representation is a 
standard technique which is widely used in 
software verification tools, such as CBMC~\cite{cbmc.tacas:2004}. 
\hwcbmcv generates a monolithic co-verification model from AIG and SSA through 
in-tandem symbolic execution of HW and FW components.  

\textbf{Step 2: Bounded Model Checking}
%
The co-verification model is checked with bounded model checking (BMC).
Given an unwind depth depth~$k$ and a co-design property $P$, BMC operates
by unwinding the co-verification model~$M$ up to depth~$k$ starting from
initial state $x_0$, represented by an initial state predicate~$I$.
This results in the following formula which is then checked for
satisfiability using an efficient SAT or SMT procedure.
%
\[ I(x_0) \wedge \bigwedge_{i=0}^{k-1} M(x_i, x_{i+1}) \wedge \bigvee_{i=0}^{k} 
\neg P(x_i) \]
%
Thus, BMC exploits the finiteness of $M$ and creates k copies of the
$M$ for each unrolling.


%\hwcbmcv provides specific handshake primitives such
%as $next\_timeframe()$ and $set\_inputs()$ to model FW-HW communications.

\textbf{Step 3: Scenario/Transaction Pair} In \hwcbmcv, the symbolic execution 
of HW and FW components meet only at the solver phase.  Thus, a complex
monolithic formula is passed on to the solver for verification purpose.  This
limits the opportunity for extracting relevant scenario/transaction pairs
through symbolic execution. Instead, the technique relies on the underlying
SAT/SMT solver to effeciently reason about the co-verification model. 
%
\Omit{
The hardware and firmware run independently of each other. 
The communication between them takes place through these function calls. 
}
%===============================================================================
\section{Property Specification for Co-verification}\label{property}
%===============================================================================
Lack of support for property specification in a HW/SW co-design is one of the
stumbling blocks for the application of formal techniques in co-verification.  
In this paper, we express a co-design property in C 
with the support of special primitive, called {\em next\_timeframe()}, 
that can express temporal correlation between HW and FW events. 
In this paper, we classify co-design properties into two 
classes -- {\em transaction level} property and {\em component level} property.
%-------------------------------------------------------------------------------
\subsection{Transaction level Property}
%-------------------------------------------------------------------------------
A {\em Transaction level} property ($\psi_{t}$) formally captures the 
design intent of the interaction between a $\mathcal{ST}$ and $\mathcal{HT}$, 
that is, it is defined at the transaction boundaries.  
Recall that a $\mathcal{ST}$ is a service in response to some external environment 
or HW interrupts (for example acknowledgement or exceptions). Similarly, 
$\mathcal{HT}$ is a finite-length service in response to some SW events or 
other HW events. 

Thus, a transaction level property follows implication structure -- the 
antecedent of the implication is an event in $\mathcal{ST}$ or 
$\mathcal{HT}$ and the consequent is an event in $\mathcal{HT}$ 
or $\mathcal{ST}$ respectively.  An event in $\mathcal{ST}$ may be 
a function call or an update to program variables. Similarly, an event in 
$\mathcal{HT}$ corresponds to an update of combinational or sequential 
elements. Figure~\ref{figure:transaction} shows an example of transaction 
level property, written as monitors in C, for the UART IP.  In $monitor\_P1()$, 
$outb(UART\_TR,0x0c)$ is a FW event and $ack\_o$ is a HW event. Whereas in
$monitor\_P2()$, the antecedent $tx\_empty()$ is a HW event and $send\_data$ is a FW
event. 
%
\begin{figure}[htbp]
\scriptsize
\begin{tabular}{l|l}
\hline
\multicolumn{2}{c}{Monitors (in C)}
\\
\hline
\begin{lstlisting}[mathescape=true,language=C,moredelim={[is][keywordstyle]{@@}{@@}}]
bool monitor_P1() { 
 if(outb(UART_TR,0x0c)){
  next_timeframe();
  assert(@@ ack_o==1 @@);}}
\end{lstlisting} 
&
\begin{lstlisting}[mathescape=true,language=C,moredelim={[is][keywordstyle]{@@}{@@}}]
bool monitor_P2() { 
 assert(!tx_empty() || 
 (@@(send_data&0x1)==1)@@);
}
\end{lstlisting} \\ 
\hline
\end{tabular}
\caption{Transaction level property as monitor (in C)}
\label{figure:transaction}
\end{figure}
%

%-------------------------------------------------------------------------------
\subsection{Component level Property}
%-------------------------------------------------------------------------------
A {\em component level} property ($\psi_{c}$) is defined purely at the 
level of individual components of a co-design system. Recall that a component 
may be a HW model, a SW model or an interface model which contains only the 
interface logic.  A component-level property captures the design intent of a 
component in terms of its input/output behaviors.  This type of property 
is useful in a co-design environment for verifying individual components.   
Note that unlike the structure of $\psi_{t}$ which requires the antecedent 
or consequent to be a HW or SW event,  $\psi_{c}$ only contains signals 
(ports) or variables of a particular component.  Figure~\ref{figure:component} 
shows an example of component level property for the UART HW only.  The 
System Verilog Assertion (SVA) is shown in the left and the equivalent 
monitor in C is shown in right.  
%
\begin{figure}[htbp]
\scriptsize
\begin{tabular}{l|l}
\hline
System Verilog Assertions  & Monitor (in C)
\\
\hline
\begin{lstlisting}[mathescape=true,language=Verilog]
P3: assert property 
 (@(posedge clk) 
 ack == 1|-> 
 (valid == 1 && 
 ##2 empty == 0)); 
\end{lstlisting}
&
\begin{lstlisting}[mathescape=true,language=C]
bool monitor_P3() {
 assert(!ack || valid);
 next_timeframe();
 next_timeframe();
 assert(empty==0); }
\end{lstlisting} \\
\hline
\end{tabular}
\caption{Component level property as monitor (in C)}
\label{figure:component}
\end{figure}
%
%-------------------------------------------------------------------------------
\subsection{Debugging Using Counterexample Trace}
%-------------------------------------------------------------------------------
A failure of co-design property implies a fault in HW or defective FW 
or bug in the interface functions.  Hence, an important feature of a
co-verification tool is its ability to produce a counterexample trace 
in order to localize the bug.  \hwcbmcv generates a counterexample
trace in value change dump (vcd) format that contains concrete assignments to FW
variables, interface signals and HW RTL signals up to a given bound. Whereas, a
counterexample trace in \verifox is a bounded path in the sequential co-verification
model that contains a scenario and its corresponding HW and FW transactions. 
%
%===============================================================================
\section{Experimental Results}
%===============================================================================
%
We report experimental results for FW-HW co-verification of a UART IP and a
SoC design.  All our experiments were performed on an Intel Xeon 3.07\,GHz
machine with 48\,GB RAM.  All times reported are in seconds.  The timeout 
for all our experiments was set to 2~hours.  
%

\textit{\textbf{State-of-the-art Co-verification tools:}} 
%There exists plethora of tools for either SW verification or HW verification.
%
Despite extensive use of model checking and other formal methods in 
SW verification or HW verification domain, building automated 
co-verification tools using formal methods has received 
little attention in the past.  We are not aware of any automated 
formal co-verification tool in the literature that can readily accept 
co-designs written in C and Verilog RTL. In this paper, we address this gap. 
%
%-------------------------------------------------------------------------------
\subsection{FW-HW co-verification of UART}
%-------------------------------------------------------------------------------

\textbf{\emph{About UART:}} A UART IP core is used for asynchronous
transmission and reception of data which provides serial communication
capabilities with a modem or other external devices.  The UART IP is
compliant with industry standards for UART and interfaces with the wishbone
bus.  The design statistics for UART is shown in Table~\ref{table:stats}.
%
\begin{table}
\begin{center}
{
\scriptsize
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
  Circuit & Verilog & Latches(L)/ & Input & Output & GATE & Firmware \\
  & LOC & FF & Ports & Ports & Count & (LOC)\\ 
\cline{1-7}
\multicolumn{7}{|c|}{Universal Asynchronous Receiver Transmitter} \\ \hline 
  UART & 1200 & 356 & 12 & 9 & 413 & 528 \\ \hline
\multicolumn{7}{|c|}{System-On-a-Chip} \\ \hline 
  SoC & 3567 & 840 & 14 & 11 & 945 & 734 \\ \hline
\end{tabular}
}
\end{center}
\caption{Design statistics for UART IP and SoC Design}
\label{table:stats}
\end{table}  
%
\textbf{\emph{UART Configuration:}} The UART IP core is configured in
different operating modes, namely--{\em transmission without interrupt
enabled} (Scenario A), {\em transmission with interrupt enabled} (Scenario
B) and {\em loopback mode with interrupt enabled} (Scenario C).  The
data-width varies in each mode, ranging from 8~bits to 64~bits.  Scenario A
and Scenario B exercises only the transmitter module to transmit
non-deterministic data through the serial output.  The receiver module is
inactive in Scenario A and Scenario B.  By contrast, in Scenario C we
configure the UART in loopback mode with interrupt logic enabled.  Thus,
both the transmitter and the receiver are active in this mode.  The firmware
can receive interrupt from the transmitter or receiver module depending on
whether the transmitter buffer is empty or the receiver buffer is full
respectively, hence the control is non-deterministic in this mode. \\
%
\textbf{\emph{Discussion:}}
Table~\ref{table:safe} reports the run times for bounded safety proofs of 
co-design properties in UART IP core.  Column~1 in Table~\ref{table:safe} 
gives the name of the scenario -- transmission
without interrupt (transmit), transmission with interrupt (trans\_intr) and
loopback mode (loopback).  Column~2 gives the maximum loop bound in the
firmware.  Column~3 present the co-verification times using \hwcbmcv
at the bit-level.  Column~4~and~5 report the total/feasible path counts and the 
percentage of infeasible paths pruned for each scenario in \verifox.  
Column~6 gives the verification times using \verifox.  Column~7 report 
the verification outcome. The focus of our experiment is to compare 
the performance of path-based technique with monolithic BMC approach for 
co-verification.  We observe similar performance of bit-level and word-level 
flow in \hwcbmcv. So, we only report bit-level results for \hwcbmcv in this paper. \\ 
\textbf{\emph{Safety properties:}}
We verify a total of~17 transaction level properties and~22 component level 
properties of the UART IP.  Table~\ref{table:safe} reports some of the
representative properties.  In Scenario~A and scenario~B, we verified whether
the transmitted data (32-bit or 64-bit) is available through the serial
output port after a pre-determined number of clock cycles.
In both of the configurations, \verifox is able to prune the receiver logic since the
FW only exercises the transmitter module by appropriately configuring
the memory-mapped registers.  In Scenario~C, we verified whether the transmitted
data matches the data received when the UART is configured in loopback
mode.\\ 
\textbf{\emph{Bug Finding:}}
We found several bugs in the open source UART IP obtained from~\url{http://www.opencores.org}.  
The bottom part of Table~\ref{table:safe} reports the verification
times for detecting data-path and control-path bugs in UART IP.  
The bug in the UART data-path is manifested in the transmission mode when no
interrupt is enabled.  The bug occurs when the transmitted data overlaps
with the start and stop bits resulting in incorrect bit pattern in the
serial output of the transmitter.  However, when the interrupt is enabled
during transmission mode, the bug in the control-path of the transmitter
module is triggered which deactivates the transmitter $empty$ signal.  This
illegally prevents any transmitter interrupt to occur even when the
transmitter buffer is empty, thereby violating the data transfer protocol. 
On the other hand, the \emph{control bug} occurs in the loopback mode only when the
data is present at the receiver buffer but the $data\_present$ signal is
never asserted, as a result of which the receiver interrupt is never issued
in the FW. Thus, the transmitted data is not the same as the received
data in loopback mode leading to a control bug.

Table~\ref{table:safe} shows that path-based symbolic execution dominates
monolithic BMC in all scenarios (marked bold).  The average speedup for
proving safety properties is on average $21\times$ for \verifox over
\hwcbmcv.  The average speedup for detecting bugs is $48\times$ on average 
for \verifox over \hwcbmcv.  Thus, \verifox outperforms \hwcbmcv 
in all scenarios. 

\Omit{
\verifox also outperforms \klee for most configurations in
Scenario~A and Scenario~C.  In Scenario~B, \klee marginally wins over
\verifox by a fraction of a second.  \cbmcv performs poorly for most
scenarios, which is mostly attributed to higher loop bound ($>500$) in the
FW, thereby causing \cbmcv to get stuck in unwinding the program netlist
model.  

Note that both \klee and \verifox were run with the same configurations --
depth-first exploration strategy, eager infeasibility check, and incremental
solving.  \klee uses the STP theorem prover, whereas \verifox uses
MiniSAT~2.2.0 in the backend.
}
\Omit
{Besides SAT backend, \verifox also have a SMT backend. We ran our 
experiments with Z3 and observe higher verification times for Z3 compared 
to MiniSAT. So, we do not report the verification with SMT solvers.   }

\begin{table}
\begin{center}
{
\begin{scriptsize}
\begin{tabular}{|l|l|l|l|l|l|l|}
\hline
  & & \multicolumn{1}{c|}{Monolithic} & \multicolumn{3}{c|}{Path-based} &
  Verification \\ 
\cline{3-6}
  Scenario & Bound & \multicolumn{1}{c|}{HW-CBMC} & \multicolumn{3}{c|}{\verifox} &
  Results \\ 
\cline{3-7}
      &       &  Bit-level & Total/Feasible & \%-age & $\mathcal{M}_{seq}$ &
      Safe/Unsafe \\
  \cline{3-3}\cline{6-6}
      &       &   Time     & Paths & Pruning & Time &  \\
\cline{1-7}      
\multicolumn{7}{|c|}{non-deterministic data but deterministic control (Scenario A)} \\ \hline
  transmit (32) & 250 & 15.02 & 247104/224 & 99.90 & \textbf{1}.\textbf{13} &
  Safe $(\psi_{c})$ \\ 
transmit (64) & 500 & 23.87 & 247104/324 & 99.86 &
  \textbf{1}.\textbf{61}  & Safe $(\psi_{t})$ \\ \hline 
\multicolumn{7}{|c|}{non-deterministic data and non-deterministic control
(Scenario B)} \\ \hline
  trans\_intr (32) & 250 & 14.86 & 247104/295 & 99.88 & \textbf{1}.\textbf{49} &
  Safe $(\psi_{t})$ \\
  trans\_intr (64) & 500 & 24.14 & 247104/362 & 99.85 & \textbf{1}.\textbf{81}
  & Safe $(\psi_{t})$ \\ \hline
\multicolumn{7}{|c|}{non-deterministic data and non-deterministic control
(scenario C)} \\ \hline
  loopback (8)  & 230 & 52.06 & 247104/354 & 99.85 & \textbf{3}.\textbf{95} &
  Safe $(\psi_{t})$ \\ 
  loopback (16) & 500 & 122.12 & 247104/690 & 99.72 & \textbf{12}.\textbf{89} &
  Safe $(\psi_{c})$ \\ 
  loopback (32) & 650 & 170.62 & 247104/1282 & 99.48 & \textbf{21}.\textbf{85} &
  Safe $(\psi_{c})$ \\ 
  loopback (64) & 1300 & 409.71 & 247104/2566 & 98.96 & \textbf{62}.\textbf{31}
  & Safe $(\psi_{t})$ \\ \hline
\multicolumn{7}{|c|}{detecting data-path bugs in transmission mode w/o interrupt} \\ \hline
  transmit (64) & 520 & 28.43 & 247104/324 & 99.86 &
  \textbf{1}.\textbf{12} & Unsafe $(\psi_{t})$ \\ \hline
\multicolumn{7}{|c|}{detecting control bugs with interrupt enabled} \\ \hline
transmit (64) & 520 & 31.35 & 247104/362 & 99.85 &
  \textbf{1}.\textbf{05} & Unsafe $(\psi_{c})$ \\ \hline
\multicolumn{7}{|c|}{detecting control bugs in loopback mode} \\ \hline
  loopback (64) & 1300 & 443.15 & 247104/2566 & 98.96 & \textbf{62}.\textbf{34}
  & Unsafe $(\psi_{t})$ \\ \hline
\end{tabular}
\end{scriptsize}
}
\end{center}
%\vspace{-1.3mm}
\caption{Bounded safety proof times for verification of UART 
\label{table:safe}}
\end{table}

%-------------------------------------------------------------------------------
\subsection{FW-HW Co-verification of System-on-Chip}
%-------------------------------------------------------------------------------

\textbf{\emph{About the SoC:}}
%
We obtained an open source System-on-a-Chip design
from~\cite{DBLP:conf/fmcad/SubramanyanVRM15}.  It consists of an 8051
micro-controller, a memory arbiter, an external memory (XRAM) and
cryptographic accelerators, as shown in Figure~\ref{fig:soc}.  
The design statistics for SoC is given in
Table~\ref{table:stats}.  The accelerator implements encryption/decryption 
using the Advanced Encryption Standard (AES).  There is a separate 
module that interfaces the AES to the 8051 micro-controller using 
a memory-mapped I/O interface.  The micro-controller communicates 
with the accelerators and the XRAM by reading or writing to 
XRAM addresses.  The arbitration of these module is done by 
the memory arbiter module. \\ 
%
\begin{figure}[t]
\scalebox{.50}{\import{figures/}{soc.pspdftex}}
  \caption{SoC Design obtained from~\cite{DBLP:conf/fmcad/SubramanyanVRM15}
\label{fig:soc}}
\end{figure}
%
\textbf{\emph{About the firmware:}}
%
The FW initiates the operation in the SoC by first writing to an
initial memory-mapped register.  The FW implements Linux-style $inb()$
and $outb()$ functions calls, which are used to communicate with the HW
ports.  The FW writes a sequence of non-deterministic data to the XRAM
port and then reads the data from the same port.  The cryptographic
accelerators use direct memory access to fetch the data from the external
memory.  The completion of the operation is determined by polling the
appropriate memory-mapped registers in the FW.
%
\begin{table}
\begin{center}
{
%\begin{scriptsize}
\begin{tabular}{|l|l|l|l|l|}
\hline
  & Bound & \multicolumn{1}{c|}{Monolithic} & \multicolumn{1}{c|}{Path-based} &
  Verification \\ 
\cline{3-4}
  Scenario &  & \multicolumn{1}{c|}{\hwcbmcv} & \verifox & Result \\ 
\cline{3-5}
      &       & Bit-level Netlist & $\mathcal{M}_{seq}$ & Safe/Unsafe \\
\cline{1-5}
      &       &   Time      & Time &  \\
\cline{1-5}      
\multicolumn{5}{|c|}{non-deterministic data and non-deterministic control} \\ \hline
  data\_transfer & 20 & 86.92 & \textbf{17}.\textbf{42} & Safe $(\psi_{t})$ \\
  \hline
  data\_transfer & 30 & 102.92 & \textbf{56}.\textbf{29} & Safe $(\psi_{c})$ \\ 
\hline
\multicolumn{5}{|c|}{non-deterministic data and non-deterministic control} \\ \hline
  data\_transfer & 20 & 92.63 & \textbf{1}.\textbf{27} & Unsafe $(\psi_{c})$ \\ 
\hline
\end{tabular}
%\end{scriptsize}
}
\end{center}
%\vspace{-1.3mm}
\caption{Bounded safety proof times for verification of a SoC 
\label{table:SoC}}
\end{table}
%
\textbf{\emph{Discussion of the result:}}
%
Table~\ref{table:SoC} gives the runtimes for bounded safety proofs of 
co-design properties in SoC.  Column~1 in
Table~\ref{table:SoC} gives the name of the scenario -- transmission with
interrupt (data\_transfer).  Column~2 report the maximum loop bound in the 
FW.  Column~3 present the co-verification times using \hwcbmcv
at the bit-level.  Columns~4 report the verification time using \verifox. 
Column~5 report the verification outcome. \\
\textbf{\emph{Safety properties:}}
%
We verify a total of 7 transaction level propertes and 12 
component level properties for the SoC co-design.  Due to space 
limitations, we describe some representative properties.  We check
whether the acknowledgment for data transmission and data reception arrives
from the micro-controller in the correct cycle.  We verify whether the
non-deterministic data transmitted through $outb()$ is the same
the data received through $inb()$.  We also verify that
reading/writing to the appropriate memory-mapped registers produce the
correct result during the data transmission phase.\\ 
\textbf{\emph{Bug Finding:}} We found one critical \emph{control bug} 
in the SoC design.  The bug is manifested when memory arbiter hardware 
wrongly arbitrates the port selection thereby forcing the write strobe 
for the external RAM to be LOW.  This violates the data transfer protocol 
in the SoC design.

The result in Table~\ref{table:SoC} shows that \verifox is approximately
$5\times$ faster than \hwcbmcv for proving safety.  For detecting bugs, 
the speedup is $72\times$ for \verifox over \hwcbmcv. \\ 
\textbf{\emph{Monolithic versus Path-based:}}
The reason for better scalability of \verifox compared to 
\hwcbmcv is attributed to the path-based exploration strategy combined 
with eager path pruning and incremental SAT solving.  In the case of SoC, 
the FW exercises only the micro-controller and transfer sequence of bytes to the XRAM port 
bypassing peripherals connected to other ports such as hardware accelerator.  
This scenario allows path-based exploration techniques to prune the logic for
accelerator and thereby generate only relevant scenario/transaction pairs.  It 
is important to note that forward symbolic execution without these optimizations 
timeout for all the benchmarks.

By contrast, \hwcbmcv is not able to prune the irrelevant transactions with
respect to a scenario due to monolithic BMC based approach.  Hence, \hwcbmcv
passes extremely complex formulas to the underlying solver, which often
contain irrelevant logic and are therefore difficult to solve.

% ===============================================================================
\section{Limitations of Proposed Approach}
% ===============================================================================
The primary motivation for constructing a sequential single threaded unified 
co-verification model is to avoid enumerating exponential number of interleavings 
between the HW and FW threads.  We have shown that this is extremely beneficial for 
co-designs that exhibits producer-consumer relationship.  
In particular, our path-based algorithm in \verifox is able to suitably exploit 
this interaction behavior in a sequential co-verification model through symbolic 
execution which generates relevant scenario/transaction pairs.  However, this approach 
is not applicable for co-designs that exhibits true concurrency~\cite{concurrency}, 
that is, a FW its interacting HW threads do not show producer-consumer relationship.  
In this case, it is imperative to consider all possible interleavings between participating 
threads in an effecient manner.  However, our experience is that such 
co-designs occurs rarely in practise. 


% ===============================================================================
\section{Related work}
% ===============================================================================

Previous work~\cite{codes14,codes15,fmcad13,memocode06} for 
co-verification have addressed the problem at the pre-RTL phase. 
However, we address the co-veri\-fi\-cation problem at the post-RTL
phase~\cite{fase10,vlsid13} where a key risk is divergence of the 
HW RTL from the behavior expected by the SW. In pre-RTL phase, 
there exists several notions of transaction, depending on the level 
of HW design granularity -- micro-architecture~\cite{mcbmq},
architecture~\cite{mcbmq}, TLM~\cite{tlm-book,hvc}. In this paper, 
we introduce a notion of transaction in RTL and FW models.      

Generating a unified co-verification model is a well-known 
technique in HW/SW co-verification.  Notably, Kurshan et al.~modeled HW and 
SW using finite state machines~\cite{fmsd02}, Monniaux in~\cite{emsoft07} modeled
HW and SW as C programs which are formally pushdown systems (PDS), 
Li et al.~in~\cite{fase10} used Buchi Automata to abstractly
model a hardware and PDS to abstractly model a software to generate a unified SW-HW model, 
called Buchi Pushdown System ({\em BPDS}).  In this paper, we construct an unified 
sequential co-verification model in C which enable us to automatically 
generate {\em scenario/transaction} pairs using path-based symbolic execution. 

A system is comprised of a set of concurrent FW and HW models, which
interleave asynchronously.  However, we observe a specific interaction
pattern, which resembles a producer-consumer relationship.  We conjecture
that this producer-consumer interaction pattern is not specific to the UART
IP or SoC designs used as exemplars in this paper.  Malik et
al.~in~\cite{hvc} showed that these patterns are meaningful in further
settings -- a Linux device driver interacting with x86 QEMU emulator code or
a Rockbox firmware interacting with an iAudio X5 device.

Common practice in industry for system-level co-verification is to 
either use emulators/accelerators or Instruction Set Simulators 
(ISS)~\cite{coverif-book}.  However, no rigorous formal verification 
effort is performed at the post-RTL phase to ensure the validity of the
FW-HW interactions.  

The concept of symbolic execution~\cite{DBLP:journals/tse/Clarke76,
DBLP:conf/pldi/GodefroidKS05, DBLP:conf/osdi/CadarDE08} is prevalent in the
software domain for automated test generation as well as bug finding.  This
technique is different from the symbolic simulation techniques that are used
in the hardware domain.  In this paper, we apply path-wise symbolic execution
to mine relevant scenario/transaction pairs for effective co-verification of 
a unified co-verification model.  

%===============================================================================
\section{Concluding Remarks}
%===============================================================================
%
In this paper, we presented two approaches for verification of 
HW/SW co-designs using formal techniques.  These approaches are 
embodied in our tool \hwcbmcv and \verifox.  We presented a 
notion of scenario and transaction for effective verification 
of co-designs.  To this end, we presented a path-based algorithm
to automatically mine scenario/transaction pairs.  We showed that 
the construction of a co-verification model must leverage specification of 
co-design properties over hardware and firmware events in order to 
successfully apply formal methods in co-verification.  To enable this, we 
presented two types of co-design properties, \emph{transaction level} and 
\emph{component level}.  Our tools support co-designs written in Verilog RTL 
and C.   

Our general observation is that monolithic BMC based approaches 
cannot prune irrelevant transactions with respect to a given scenario, 
and hence generate very complex formulas, which are difficult to solve. 
Owing to specific optimizations in \verifox such as eager path pruning
combined with incremental SAT solving, we experimentally show that \verifox
is an order of magnitude faster than the \hwcbmcv.  We demonstrate applicability of our
approach for proving safety as well as finding critical co-design bugs for 
a UART IP and a complex SoC design.  In the future, we plan to extend our 
framework to co-design models that exhibit further interaction patterns.

%\bibliographystyle{ACM-Reference-Format}
\bibliographystyle{abbrv}
\bibliography{biblio} 

\end{document}
